# -*- coding: utf-8 -*-
"""
Created on Tue Oct 25 16:15:06 2016

@author: Maria Schilstra
"""
# Original:
#from PyQt5.uic import loadUiType
#Ui_MainWindow, QMainWindow = loadUiType('spectral.ui')

# To avoid using .ui file (from QtDesigner) and loadUIType, 
# created a python-version of the .ui file using pyuic5 from command line
# Here: pyuic5 spectral.ui -o spectral_ui.py
# Then import .py package, as below.
# (QMainWindow is a QtWidget; UI_MainWindow is generated by the converted .ui)
# Also necessary to create a python version of the resource file (spectral.qrc)
# which is called spectral_rc.py, by using pyrcc5 as follows: 
# pyrcc5 -o spectral_rc.py spectral.qrc 


import sys

import numpy as np

from PyQt5 import QtGui as gui
from PyQt5 import QtCore as qt
from PyQt5 import QtWidgets as widgets

from spectral_mpl import MplCanvas, NavigationToolbar
from spectral_curve_handler import SpectralCurveHandler

from math_dialog import MathDialog
from params_dialog import ParamsDialog
from resample_dialog import ResampleDialog
from stats_dialog import StatsDialog
from scatter_dialog import ScatterDialog

import spectral_ui as ui

# Global constants

class Main(widgets.QMainWindow, ui.Ui_MainWindow):
    
    unit_strings = {'dAbs': '\u0394Abs',
                 'dEps_mrw': '\u0394\u03b5-mrw (M\u207b\u00b9.cm\u207b\u00b9)',
                 'dEps_M': '\u0394\u03b5-M (M\u207b\u00b9.cm\u207b\u00b9)',
                 'intensity': 'Intensity',
                 'absorbance': 'Absorbance',
                 }
    colour_seq = ['blue',
                 'green',
                 'red',
                 'orange',
                 'cyan',
                 'magenta',
                 'purple',
                 'brown',
                 'gray',
                 'black', 
                 ] 
    tbl_columns = range(10)
    (h_chk, h_id, h_uni, h_off, h_fac, h_mnx, h_mxx, h_stp, h_ndv, h_com) = tbl_columns
    tbl_headers = {h_chk: 'Select',
                   h_id: 'File',
                   h_off: 'Offset', 
                   h_fac: 'Factor',
                   h_mnx: 'X-min',
                   h_mxx: 'X-max',
                   h_uni: 'Quantity',
                   h_ndv: 'Deriv',
                   h_com: 'Composition',
                   h_stp: 'Step \n(stdev)',
                   }

       
    def __init__(self, ):
        super(Main, self).__init__()
        self.setupUi(self)  
                        
        self.canvas = MplCanvas(self.mpl_window)
        self.mpl_layout.addWidget(self.canvas)
        self.plot_toolbar = NavigationToolbar(self.canvas, self.mpl_window)
        self.mpl_layout.addWidget(self.canvas)
        self.mpl_layout.addWidget(self.plot_toolbar)
        
        labels = []
        for i in self.tbl_columns:
            labels.append(self.tbl_headers[i])
        self.tbl_files.setColumnCount(len(labels))
        self.tbl_files.setHorizontalHeaderLabels(labels)
        self.tbl_files.resizeColumnsToContents()
        
        self.chk_all_files.clicked.connect(self.on_check_all)
        self.tbl_files.itemChanged.connect(self.on_item_changed)
        
        self.rb_dAbs.setText('To ' + self.unit_strings['dAbs'])
        self.rb_dEps_mrw.setText('To ' + self.unit_strings['dEps_mrw'])
        self.rb_dEps_M.setText('To ' + self.unit_strings['dEps_M'])
        
        self.btn_open.clicked.connect(self.on_open)
        self.btn_save_csv.clicked.connect(self.on_save)
        self.btn_save_cdpro.clicked.connect(self.on_save_cdpro)
        self.btn_deriv.clicked.connect(self.on_deriv)
        self.btn_hide.clicked.connect(self.on_hide_show_curves)
        self.btn_remove.clicked.connect(self.on_remove_curves)
        self.btn_smooth.clicked.connect(self.on_smooth)
        self.btn_reset.clicked.connect(self.on_reset)
        self.btn_resample.clicked.connect(self.on_resample)
        self.btn_convert.clicked.connect(self.on_convert)
        self.btn_stats.clicked.connect(self.on_stats)
        self.btn_subtract_bl.clicked.connect(self.on_subtract_baseline)
        self.btn_math.clicked.connect(self.on_math)
        self.btn_scatter.clicked.connect(self.on_scatter)
        self.btn_copy.clicked.connect(self.on_copy)
       
        self.math_dialog = None
        self.params_dialog = None
        self.resample_dialog = None
        self.stats_dialog = None
        self.scatter_dialog = None
        
        self.curve_handler = SpectralCurveHandler()
        self.ui_curves = {}
        self.current_colour_index = 0
        
        self.set_buttons()
        
####  Event handlers  ####
            
    def on_check_all(self):
        chkd = qt.Qt.Unchecked
        if self.chk_all_files.isChecked():
            chkd = qt.Qt.Checked
        for row in range(self.tbl_files.rowCount()):
            ti = self.tbl_files.item(row, self.h_chk)
            ti.setCheckState(chkd)
    
    def on_convert(self):
        target = ''
        if self.rb_dAbs.isChecked():
            target = 'dAbs'
        if self.rb_dEps_mrw.isChecked():
            target = 'dEps_mrw'
        if self.rb_dEps_M.isChecked():
            target = 'dEps_M'
        keys = self.get_checked_curves()
        if len(keys) > 0:
            params = self.curve_handler.get_conversion_params(keys)
            self.params_dialog = ParamsDialog(main, params, target)
            if self.params_dialog.exec() == widgets.QDialog.Accepted:
                new_params = self.params_dialog.get_params()
                self.curve_handler.set_conversion_params(new_params)
                self.curve_handler.convert(keys, target)
                self.update_table(keys)
                self.plot_curves() 
                self.set_buttons()

    def on_copy(self):
        keys = self.get_checked_curves()
        new_keys = []
        for key in keys:
            new_key = key + " (copy)"
            n = 1
            while new_key in self.ui_curves.keys():
                n += 1
                new_key = key + " (copy {0})".format(n)
            new_keys.append(new_key)
        self.curve_handler.copy_curves(keys, new_keys)
        for key in new_keys:
            if key not in self.ui_curves:
                clr = self.get_current_color()
                self.increment_color()    
                self.ui_curves[key] = {'color': clr, 'visible': True, }
        self.update_table(new_keys)
        self.plot_curves()
        self.set_buttons()        
                
    def on_deriv(self):
        keys = self.get_checked_curves()
        self.curve_handler.smooth_curves(keys, 0, 1, 1)
        self.update_table(keys)
        self.plot_curves()
        self.set_buttons()
        
    def on_hide_show_curves(self):
        keys = self.get_checked_curves()
        for key in keys:
            self.ui_curves[key]['visible'] = not self.ui_curves[key]['visible']
        self.update_table(keys)
        self.plot_curves()
        self.set_buttons()
        
    def on_item_changed(self, item):
        col = item.column()
        if col in (self.h_off, self.h_fac, self.h_mnx, self.h_mxx):
            if self.is_number(item.text()):
                attrs = {self.h_off: 'offset', self.h_fac: 'factor', 
                         self.h_mnx: 'x_min', self.h_mxx: 'x_max'}
                key = self.tbl_files.item(item.row(), self.h_id).text()
                val = float(item.text())
                attr = attrs[col]  # self.h_off etc are actually col nrs
                eq = self.curve_handler.attr_value_equal(key, attr, val)
                if not eq:
                    self.curve_handler.modify([key], attr, [val])
                    self.update_table([key])
                    self.plot_curves()
        if col in (self.h_chk,):
            self.set_buttons()

    def on_math(self):
        self.math_dialog = MathDialog(main)
        if not self.math_dialog is None:
            keys = self.get_checked_curves()
            self.math_dialog.update_table(keys)
        self.math_dialog.exec()
        self.set_buttons()

    def on_open(self):
        file_list = widgets.QFileDialog.getOpenFileNames(None, 
            "Open Data File", "", "Text data files, CSV format (*.txt)")[0]
        keys = []
        for f in file_list:
            with open(f, 'r') as file:
                key = qt.QFileInfo(f).fileName()
                keys.append(key)
                curve = self.curve_handler.read_input_file(key, file)
                self.curve_handler.add_curve(curve)
                if key not in self.ui_curves:
                    clr = self.get_current_color()
                    self.increment_color()    
                    self.ui_curves[key] = {'color': clr, 'visible': True, }
        self.update_table(keys)
        self.plot_curves()
        self.set_buttons()

    def on_remove_curves(self):
        keys = self.get_checked_curves()
        for key in keys:
            self.ui_curves.pop(key)
        self.curve_handler.remove_curves(keys)
        self.remove_curves_from_table(keys)
        self.plot_curves()
        self.set_buttons()
        
    def on_resample(self):
        keys = self.get_checked_curves()
        x_min = []
        x_max = []
        dx = []
        for key in keys:
            curve = self.curve_handler.curves[key]
            n, x = curve.x_min(), curve.x_max()
            d, s = curve.x_step()            
            x_min.append(n)
            x_max.append(x)
            dx.append(d)
        x_start = np.array(x_min).max()
        x_end = np.array(x_max).min()
        x_step = np.array(dx).mean()
        self.resample_dialog = ResampleDialog(main, x_start, x_end, x_step)
        if self.resample_dialog.exec() == widgets.QDialog.Accepted:
            x_start, x_end, x_step = self.resample_dialog.get_values()
            self.curve_handler.resample(keys, x_start, x_end, x_step)
            self.update_table(keys)
            self.plot_curves()
            self.set_buttons()

    def on_reset(self):
        keys = self.get_checked_curves()
        self.curve_handler.reset_to_original(keys)
        self.update_table(keys)
        self.plot_curves()
        self.set_buttons()
        
    def on_save(self):
        keys = self.get_checked_curves()
        if len(keys) > 0:
            file_path = widgets.QFileDialog.getSaveFileName(self, 
                                    "Save Results", 
                                    "", 
                                    "CSV data files (*.csv) ;; \
                                    Text files (*.txt) ;; All files (*.*)",
                                    )[0]            
            results = self.curve_handler.create_output(keys)
            with open(file_path, 'w') as file:
                file.write(results)
        
    def on_save_cdpro(self):
        keys = self.get_checked_curves()
        file_path = widgets.QFileDialog.getSaveFileName(self, 
                                    "Save as CDPro Input File", 
                                    "INPUT", 
                                    "All files *.",
                                    )[0]
        if file_path:
            contents = self.curve_handler.create_cdpro_input(keys)
            for i in range(len(contents)):
                name = file_path
                if i > 0:
                    name += '(' + '{:02}'.format(i) + ')' 
                with open(name, 'w') as file:
                    file.write(contents[i][0])
                    
    def on_scatter(self):
        keys = self.get_checked_curves()
        self.scatter_dialog = ScatterDialog(main, keys)
        if self.scatter_dialog.exec() == widgets.QDialog.Accepted:
            self.scatter_dialog.set_scatter_correction()
            self.plot_curves()
            self.set_buttons()
                    
    def on_smooth(self):
        keys = self.get_checked_curves()
        order, window = self.get_smooth_params()
        self.curve_handler.smooth_curves(keys, window, order, 0)
        self.update_table(keys)
        self.plot_curves()
        self.set_buttons()
        
    def on_stats(self):
        keys = self.get_checked_curves()
        stats = self.curve_handler.get_stats(keys)
        self.stats_dialog = StatsDialog(main, stats)
        self.stats_dialog.exec()
        
    def on_subtract_baseline(self):
        file_path = widgets.QFileDialog.getOpenFileName(self, 
        "Open Data File", "", "All files (*.*)")[0]
        if file_path:
            keys = self.get_checked_curves()
            with open(file_path, 'r') as file:
                bl_key = qt.QFileInfo(file_path).fileName()
                self.curve_handler.subtract_baseline(keys, bl_key, file)
            self.update_table(keys)
            self.plot_curves()
            self.set_buttons()
        
        
##### Auxiliary operations ###############

    def set_buttons(self):
        self.disable_buttons()
        self.btn_open.setEnabled(True)
        keys = self.get_checked_curves()
        if len(keys) > 0:
            self.btn_save_csv.setEnabled(True)
            self.btn_deriv.setEnabled(True)
            self.btn_hide.setEnabled(True)
            self.btn_remove.setEnabled(True)
            self.btn_smooth.setEnabled(True)
            self.btn_reset.setEnabled(True)
            self.btn_stats.setEnabled(True)
            self.btn_copy.setEnabled(True)
            self.spin_smooth_window.setEnabled(True)        
            self.lbl_smooth_window.setEnabled(True)        
            self.spin_smooth_order.setEnabled(True)
            self.lbl_smooth_order.setEnabled(True)
        if self.curve_handler.suitable_for_conversion(keys):
            self.btn_convert.setEnabled(True)
            self.rb_dAbs.setEnabled(True)
            self.rb_dEps_mrw.setEnabled(True)
            self.rb_dEps_M.setEnabled(True)
        if self.curve_handler.suitable_for_cdpro(keys):
            self.btn_save_cdpro.setEnabled(True)
        if self.curve_handler.suitable_for_scatter_correction(keys):
            self.btn_scatter.setEnabled(True)
        if self.curve_handler.suitable_for_bl_subtraction(keys):
            self.btn_subtract_bl.setEnabled(True)
        if self.curve_handler.curves_overlap(keys):
            self.btn_resample.setEnabled(True)
        if self.curve_handler.suitable_for_combination(keys):
            self.btn_math.setEnabled(True)          

    def disable_buttons(self):
        self.btn_open.setEnabled(False)
        self.btn_save_csv.setEnabled(False)
        self.btn_save_cdpro.setEnabled(False)
        self.btn_deriv.setEnabled(False)
        self.btn_hide.setEnabled(False)
        self.btn_remove.setEnabled(False)
        self.btn_smooth.setEnabled(False)
        self.btn_reset.setEnabled(False)
        self.btn_resample.setEnabled(False)
        self.btn_convert.setEnabled(False)
        self.btn_stats.setEnabled(False)
        self.btn_subtract_bl.setEnabled(False)
        self.btn_math.setEnabled(False)
        self.btn_scatter.setEnabled(False)
        self.btn_copy.setEnabled(False)

        self.rb_dAbs.setEnabled(False)
        self.rb_dEps_mrw.setEnabled(False)
        self.rb_dEps_M.setEnabled(False)

        self.spin_smooth_window.setEnabled(False)        
        self.lbl_smooth_window.setEnabled(False)        
        self.spin_smooth_order.setEnabled(False)
        self.lbl_smooth_order.setEnabled(False)
        
    def combine_curves(self, op, combi_key, keys, factors, inverted):
        curve = self.curve_handler.combine_curves(op, combi_key, 
                                                  keys, factors, inverted)
        self.curve_handler.add_curve(curve)
        if combi_key not in self.ui_curves:
            clr = self.get_current_color()
            self.increment_color()    
            self.ui_curves[combi_key] = {'color': clr, 'visible': True, }
        self.update_table([combi_key])
        self.plot_curves()
            
    def find_table_item_row(self, key):
        items = self.tbl_files.findItems(key, qt.Qt.MatchExactly)
        if len(items) > 0:
            return self.tbl_files.row(items[0])
        return -1 
        
    def get_checked_curves(self):
        keys = []
        for row in range(self.tbl_files.rowCount()):
            if self.tbl_files.item(row, self.h_chk).checkState() == qt.Qt.Checked:
                key = self.tbl_files.item(row, self.h_id).text()
                keys.append(key)
        return keys
        
    def get_current_color(self):
        return self.colour_seq[self.current_colour_index]
        
    def increment_color(self):
        self.current_colour_index = \
            (self.current_colour_index + 1) % len(self.colour_seq)
        
    def curve_color(self, key):
        if self.ui_curves[key]['visible'] == True:
            return self.ui_curves[key]['color']
        return 'transparent'
                
    def update_table(self, keys):
        for key in keys:
            row = self.find_table_item_row(key)
            if row == -1:
                row = self.tbl_files.rowCount()
                self.tbl_files.insertRow(row)
                for i in self.tbl_columns:
                    ti = widgets.QTableWidgetItem()
                    if i not in (self.h_chk, self.h_off, self.h_fac, self.h_mnx, self.h_mxx):
                        ti.setFlags(qt.Qt.ItemIsEnabled)
                    self.tbl_files.setItem(row, i, ti)
                ti = self.tbl_files.item(row, self.h_id)
                ti.setText(key)
                ti = self.tbl_files.item(row, self.h_chk)
                ti.setCheckState(qt.Qt.Unchecked)            
            curve = self.curve_handler.curves[key]
            attr = curve.attributes
            ti = self.tbl_files.item(row, self.h_chk)
            clr = self.curve_color(key)
            icon = self.line_icon(clr)
            ti.setIcon(icon)  
            ti = self.tbl_files.item(row, self.h_off)
            ti.setText('{:+.2E}'.format(attr['offset']))
            ti = self.tbl_files.item(row, self.h_fac)
            ti.setText('{:+.2E}'.format(attr['factor']))
            ti = self.tbl_files.item(row, self.h_mnx)
            ti.setText('{:.2f}'.format(curve.x_min()))
            ti = self.tbl_files.item(row, self.h_mxx)
            ti.setText('{:.2f}'.format(curve.x_max()))
            ti = self.tbl_files.item(row, self.h_stp)
            d, dd = curve.x_step()
            ti.setText('{:.3f}\n({:.3f})'.format(d, dd))
            ti = self.tbl_files.item(row, self.h_uni)
            ti.setText(self.unit_strings[attr['y_units']])
            ti = self.tbl_files.item(row, self.h_ndv)
            ti.setText('{:^}'.format(attr['n_deriv']))
            ti.setTextAlignment(qt.Qt.AlignCenter)
            ti = self.tbl_files.item(row, self.h_com)
            ti.setText(attr['composition']) 
        self.tbl_files.resizeColumnsToContents()
        
    def remove_curves_from_table(self, keys):
        for key in keys:
            items = self.tbl_files.findItems(key, qt.Qt.MatchExactly)
            for i in items: # should only be one row, as key is unique
                row = self.tbl_files.row(i)
                self.tbl_files.removeRow(row)

    def plot_curves(self):
        self.canvas.main_plot.cla()
        xlabels, ylabels = [], []
        for key in self.ui_curves.keys():
            if self.ui_curves[key]['visible']: 
                # checknecessary as mpl does not seem to recognise 'transparent'
                curve = self.curve_handler.curves[key]
                data = curve.working_data
                x, y = data['X'], data['Y1']
                clr = self.curve_color(key)
                self.canvas.main_plot.plot(x, y, c=clr)
                xlabels.append(curve.attributes['x_units'])
                ylabels.append(curve.attributes['y_units'])
        xl = np.unique(xlabels).tolist()
        yl = np.unique(ylabels).tolist()
        xlabel, ylabel = "", ""
        if len(xl) > 0:
            xlabel = xl.pop()
            while len(xl) > 0:
                xlabel += ", "
                xlabel += xl.pop()
        if len(yl) > 0:
            ylabel = yl.pop()
            while len(yl):
                ylabel += ", "
                ylabel += yl.pop()
        self.canvas.main_plot.set_xlabel(xlabel)
        self.canvas.main_plot.set_ylabel(ylabel)
        self.canvas.fig.canvas.draw()

    def get_smooth_params(self):
        order = self.spin_smooth_order.value()
        window = self.spin_smooth_window.value()
        return order, window
        
    def is_number(self, s):
        try:
            float(s)
            return True
        except ValueError:
            return False
        
    def line_icon(self, color):
        pixmap = gui.QPixmap(50,10)
        pixmap.fill(gui.QColor(color))
        icon = gui.QIcon(pixmap)
        return icon
        

 # Standard main loop code
if __name__ == '__main__':
    app = widgets.QApplication(sys.argv)
    main = Main()
    main.show()
#    app.exec_()
    sys.exit(app.exec_())   



